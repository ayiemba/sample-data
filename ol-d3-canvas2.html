<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLayers with D3 for Lines, Polygons, and Multipolygons</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.3.1/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0"></script> <!-- Include Turf.js -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.3.1/ol.css">
    <style>
        html,
        body,
        #map {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

    </style>
</head>

<body>
    <div id="map"></div>

    <script>

        function canvasFunction(extent, resolution, pixelRatio, size, projection, styleFunction) {
            var canvasWidth = size[0];
            var canvasHeight = size[1];

            var canvas = d3.select(document.createElement('canvas'));
            canvas.attr('width', canvasWidth).attr('height', canvasHeight);

            var context = canvas.node().getContext('2d');

            var d3Projection = d3.geoMercator().scale(1).translate([0, 0]);
            var d3Path = d3.geoPath().projection(d3Projection);

            var geoBounds = d3.geoBounds(features);
            var geoBoundsLeftBottom = ol.proj.fromLonLat(geoBounds[0], projection);
            var geoBoundsRightTop = ol.proj.fromLonLat(geoBounds[1], projection);
            var geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];
            if (geoBoundsWidth < 0) {
                geoBoundsWidth += ol.extent.getWidth(projection.getExtent());
            }
            var geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];

            var pixelBounds = d3Path.bounds(features);
            var pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];
            var pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];

            var widthResolution = geoBoundsWidth / pixelBoundsWidth;
            var heightResolution = geoBoundsHeight / pixelBoundsHeight;
            var scale = Math.max(widthResolution, heightResolution) / (resolution / pixelRatio);
            var center = ol.proj.toLonLat(ol.extent.getCenter(extent), projection);

            d3Projection.scale(scale).center(center).translate([canvasWidth / 2, canvasHeight / 2]);
            d3Path = d3Path.projection(d3Projection).context(context);

            // Array to store features for hit detection
            const renderedFeatures = [];

            // Loop through features and style them dynamically
            features.forEach(feature => {
                const properties = feature.properties;

                // Apply the style function to get styles
                const style = styleFunction(properties) || {};
                const { strokeStyle = '#000', fillStyle = 'none', lineWidth = 1 } = style;

                // Apply styles
                context.strokeStyle = strokeStyle;
                context.fillStyle = fillStyle;
                context.lineWidth = lineWidth;

                // Render feature
                context.beginPath();
                d3Path(feature);

                // Store path and feature for hit detection
                renderedFeatures.push({
                    feature: feature,
                    path: d3Path(feature)
                });

                if (fillStyle !== 'none') {
                    context.fill();
                }
                context.stroke();
            });

            // Add interactivity
            canvas.on('mousemove', function (event) {
                const [mouseX, mouseY] = d3.pointer(event);

                // Check if the mouse is over any feature
                let hoveredFeature = null;
                renderedFeatures.forEach(({ feature }) => {
                    if (d3Path.contains(feature, [mouseX, mouseY])) {
                        hoveredFeature = feature;
                    }
                });

                if (hoveredFeature) {
                    // Change style dynamically (e.g., highlight feature)
                    const highlightStyle = {
                        strokeStyle: 'red',
                        fillStyle: 'rgba(255, 0, 0, 0.3)',
                        lineWidth: 2
                    };

                    // Redraw the feature with the highlight style
                    context.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
                    features.forEach(f => {
                        const isHovered = f === hoveredFeature;
                        const style = isHovered ? highlightStyle : styleFunction(f.properties) || {};
                        const { strokeStyle = '#000', fillStyle = 'none', lineWidth = 1 } = style;

                        context.strokeStyle = strokeStyle;
                        context.fillStyle = fillStyle;
                        context.lineWidth = lineWidth;

                        context.beginPath();
                        d3Path(f);
                        if (fillStyle !== 'none') {
                            context.fill();
                        }
                        context.stroke();
                    });

                    // Return the ID or properties of the hovered feature
                    console.log('Hovered Feature ID:', hoveredFeature.properties.id);
                } else {
                    // Optional: Reset the canvas if no feature is hovered
                    context.clearRect(0, 0, canvasWidth, canvasHeight);
                    features.forEach(f => {
                        const style = styleFunction(f.properties) || {};
                        const { strokeStyle = '#000', fillStyle = 'none', lineWidth = 1 } = style;

                        context.strokeStyle = strokeStyle;
                        context.fillStyle = fillStyle;
                        context.lineWidth = lineWidth;

                        context.beginPath();
                        d3Path(f);
                        if (fillStyle !== 'none') {
                            context.fill();
                        }
                        context.stroke();
                    });
                }
            });

            return canvas.node();
        }

    </script>



</body>