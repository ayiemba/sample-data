<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLayers with D3 for Lines, Polygons, and Multipolygons</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.3.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.3.1/ol.css">
    <style>
        html,
        body,
        #map {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        .custom-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <svg id="d3-svg" class="custom-svg"></svg>
    <script>
        // 1. Initialize the OpenLayers Map
        const map = new ol.Map({
            target: 'map',
            view: new ol.View({
                center: ol.proj.fromLonLat([36.8219, -1.2921]), // Nairobi, Kenya
                zoom: 6,
            }),
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM(), // OpenStreetMap Basemap
                }),
            ],
        });

        // 2. Setup the D3 SVG container
        const d3Svg = d3.select("#d3-svg");

        // Resize and sync SVG size with the map
        const resizeSvg = () => {
            const size = map.getSize();
            d3Svg.attr("width", size[0]).attr("height", size[1]);
        };
        map.on('resize', resizeSvg);
        resizeSvg();

        // 3. Sample Data
        const data = {
            points: [
                { lon: 36.8219, lat: -1.2921, magnitude: 5.1 }, // Nairobi
            ],
            lines: [
                {
                    type: 'LineString',
                    coordinates: [
                        [36.8219, -1.2921], // Nairobi
                        [37.075, -0.5143],  // Meru
                        [35.282, 0.515],    // Eldoret
                    ],
                },
            ],
            polygons: [
                {
                    type: 'Polygon',
                    coordinates: [
                        [
                            [36.8, -1.3],
                            [36.9, -1.3],
                            [36.9, -1.2],
                            [36.8, -1.2],
                            [36.8, -1.3],
                        ],
                    ],
                },
            ],
            multipolygons: [
                {
                    type: 'MultiPolygon',
                    coordinates: [
                        [
                            [
                                [36.7, -1.4],
                                [36.8, -1.4],
                                [36.8, -1.3],
                                [36.7, -1.3],
                                [36.7, -1.4],
                            ],
                        ],
                        [
                            [
                                [36.9, -1.5],
                                [37.0, -1.5],
                                [37.0, -1.4],
                                [36.9, -1.4],
                                [36.9, -1.5],
                            ],
                        ],
                    ],
                },
            ],
        };

        // 4. Render Features using D3 and SVG
        const renderD3 = () => {
            // Clear previous SVG elements
            d3Svg.selectAll("*").remove();

            const extent = map.getView().calculateExtent();
            const projection = map.getView().getProjection();

            // Helper function to check if a line segment is within the extent
            const isSegmentVisible = (coord1, coord2) => {
                const c1Inside = ol.extent.containsCoordinate(extent, coord1);
                const c2Inside = ol.extent.containsCoordinate(extent, coord2);
                return c1Inside || c2Inside; // At least one endpoint visible
            };

            // 4.1 Create Groups for Points, Lines, and Polygons
            const polygonGroup = d3Svg.append("g").attr("class", "polygons");
            const lineGroup = d3Svg.append("g").attr("class", "lines");
            const pointGroup = d3Svg.append("g").attr("class", "points");


            // 4.2 Render Points (Handle visibility)
            data.points.forEach((point) => {
                const coordinate = ol.proj.transform([point.lon, point.lat], 'EPSG:4326', projection);
                const pixel = map.getPixelFromCoordinate(coordinate);

                if (pixel) { // Only render if pixel is valid
                    pointGroup.append("circle")
                        .attr("cx", pixel[0])
                        .attr("cy", pixel[1])
                        .attr("r", point.magnitude * 2)
                        .attr("fill", "rgba(255, 0, 0, 0.5)")
                        .attr("stroke", "red")
                        .attr("stroke-width", 1);
                }
            });

            // 4.3 Render Lines (Handle partial visibility)
            data.lines.forEach((line) => {
                const lineData = line.coordinates.map((coord) => {
                    return ol.proj.transform(coord, 'EPSG:4326', projection);
                });

                // Filter the line data based on visibility
                const visibleCoords = lineData.filter((coord, index) => {
                    const prevCoord = lineData[index - 1];
                    return index === 0 || isSegmentVisible(prevCoord, coord);
                });

                // Only render if there are valid coordinates
                if (visibleCoords.length > 1) {
                    const validCoords = visibleCoords.filter(coord => {
                        const pixel = map.getPixelFromCoordinate(coord);
                        return pixel !== null; // Only include valid pixels
                    });

                    // Only draw the line if there are valid pixels
                    if (validCoords.length > 1) {
                        const linePath = d3.line()
                            .x(d => {
                                const pixel = map.getPixelFromCoordinate(d);
                                return pixel ? pixel[0] : null;
                            })
                            .y(d => {
                                const pixel = map.getPixelFromCoordinate(d);
                                return pixel ? pixel[1] : null;
                            });

                        lineGroup.append("path")
                            .data([validCoords])
                            .attr("d", linePath)
                            .attr("stroke", "blue")
                            .attr("stroke-width", 2)
                            .attr("fill", "none");
                    }
                }
            });

            // 4.4 Render Polygons (Handle visibility)
            data.polygons.forEach((polygon) => {
                const coordinates = polygon.coordinates[0].map((coord) => {
                    return ol.proj.transform(coord, 'EPSG:4326', projection);
                });

                // Filter the polygon vertices based on visibility
                const validCoords = coordinates.filter(coord => {
                    const pixel = map.getPixelFromCoordinate(coord);
                    return pixel !== null; // Only include valid pixels
                });

                if (validCoords.length > 2) { // Need at least 3 points to form a polygon
                    const polygonPath = d3.line()
                        .x(d => {
                            const pixel = map.getPixelFromCoordinate(d);
                            return pixel ? pixel[0] : null;
                        })
                        .y(d => {
                            const pixel = map.getPixelFromCoordinate(d);
                            return pixel ? pixel[1] : null;
                        });

                    polygonGroup.append("path")
                        .data([validCoords])
                        .attr("d", polygonPath)
                        .attr("fill", "rgba(0, 255, 0, 1)")
                        .attr("stroke", "green")
                        .attr("stroke-width", 2);
                }
            });

            // 4.5 Render Multipolygons (Handle visibility)
            data.multipolygons.forEach((multipolygon) => {
                multipolygon.coordinates.forEach((polygon) => {
                    const coordinates = polygon[0].map((coord) => {
                        return ol.proj.transform(coord, 'EPSG:4326', projection);
                    });

                    // Filter the polygon vertices based on visibility
                    const validCoords = coordinates.filter(coord => {
                        const pixel = map.getPixelFromCoordinate(coord);
                        return pixel !== null; // Only include valid pixels
                    });

                    if (validCoords.length > 2) { // Need at least 3 points to form a polygon
                        const multipolygonPath = d3.line()
                            .x(d => {
                                const pixel = map.getPixelFromCoordinate(d);
                                return pixel ? pixel[0] : null;
                            })
                            .y(d => {
                                const pixel = map.getPixelFromCoordinate(d);
                                return pixel ? pixel[1] : null;
                            });

                        polygonGroup.append("path")
                            .data([validCoords])
                            .attr("d", multipolygonPath)
                            .attr("fill", "rgba(0, 0, 255, 0.5)")
                            .attr("stroke", "blue")
                            .attr("stroke-width", 2);
                    }
                });
            });

        };

        let lastExtent = null;

       
        // 5. Sync SVG with Map Viewport
        map.on('postrender', () => {
            const rect = map.getViewport().getBoundingClientRect();
            d3Svg.style("position", "absolute")
                .style("top", `${rect.top}px`)
                .style("left", `${rect.left}px`)
                .attr("width", map.getSize()[0])
                .attr("height", map.getSize()[1]);
        });

        // 6. Animate and Redraw Features
        renderD3(); // Initial render
        map.on('postrender', () => {
            const extent = map.getView().calculateExtent();
            if (lastExtent && ol.extent.equals(lastExtent, extent)) {
                return; // No need to redraw if the extent hasn't changed
            }
            lastExtent = extent;
            renderD3(); // Call render only when the extent has changed
        });
        //map.on('postrender', renderD3); // Redraw after render
        map.on('moveend', renderD3);   // Redraw after movement
    </script>
</body>

</html>