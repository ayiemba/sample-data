<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLayers and D3 Integration</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@v10.3.1/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.3.1/ol.css">

    <style>
        html,
        body,
        #map {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        svg {
            pointer-events: none;
            /* Prevent interference with map interaction */
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>
        // Initialize OpenLayers Map
        const map = new ol.Map({
            target: 'map',
            view: new ol.View({

                center: ol.proj.fromLonLat([0, 0]), // Center the map at the origin
                zoom: 1,
                extent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34], // world bounds
                constrainOnlyCenter: false,
            }),
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM(), // OpenStreetMap Basemap
                }),
            ],
        });

        // Custom Layer Class
        class CanvasLayer extends ol.layer.Layer {
            constructor(options) {
                super(options);

                this.features = options.features.features; // GeoJSON features
                console.log('features:', this.features);

                // Create the SVG container
                this.svgContainer = d3.select(document.createElement('div'))
                    .style('position', 'absolute')
                    .style('top', '0')
                    .style('left', '0')
                    .style('width', '100%')
                    .style('height', '100%')
                    .append('svg')
                    .style('position', 'absolute')
                    .style('width', '100%')
                    .style('height', '100%');

                this.svgLayer = this.svgContainer.append('g');
            }

            getSourceState() {
                return 'ready';
            }

            render(frameState) {
                const width = frameState.size[0]; // Width of the map viewport
                const height = frameState.size[1]; // Height of the map viewport
                const projection = frameState.viewState.projection;

                const d3Projection = d3.geoMercator().scale(1).translate([0, 0]);
                let d3Path = d3.geoPath().projection(d3Projection);

                // Clear existing paths to avoid duplication
                this.svgLayer.selectAll('path').remove();

                // Adjust the SVG container dimensions
                this.svgContainer
                    .attr('width', width)  // Match the map viewport width
                    .attr('height', height); // Match the map viewport height

                console.log('svgcontainer', this.svgContainer);

                // Use d3.geoBounds() to calculate the bounds of all features
                const bounds = d3.geoBounds({
                    type: 'FeatureCollection',
                    features: this.features,
                });

                console.log('geobounds', bounds);



                // Calculate scale and resolution based on bounds and pixel size
                const pixelBounds = d3Path.bounds({
                    type: 'FeatureCollection',
                    features: this.features,
                });

                console.log('pixelbounds', pixelBounds);

                const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];
                const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];

                const geoBoundsLeftBottom = ol.proj.fromLonLat(bounds[0], projection);
                const geoBoundsRightTop = ol.proj.fromLonLat(bounds[1], projection);
                const geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];
                const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];

                // Calculate width and height resolution
                const widthResolution = geoBoundsWidth / pixelBoundsWidth;
                const heightResolution = geoBoundsHeight / pixelBoundsHeight;
                const r = Math.max(widthResolution, heightResolution);
                const scale = r / frameState.viewState.resolution;

                console.log('r', r);
                console.log('scale', scale);
                console.log('resolution', frameState.viewState.resolution);

                // Calculate the center of the map
                const centerCoordinate = ol.proj.toLonLat(ol.extent.getCenter(frameState.extent), projection);
                const center = [centerCoordinate[0], centerCoordinate[1]];
                const angle = (-frameState.viewState.rotation * 180) / Math.PI;

                // Apply scale, center, and angle to the D3 projection
                d3Projection
                    .scale(100)
                    .center(center)
                    .translate([width / 2, height / 2])
                    .angle(angle);

                d3Path = d3Path.projection(d3Projection);
                //var d3Path = d3.geoPath(null);

                // Add paths for all features
                this.features.forEach((feature) => {
                    this.svgLayer.append('path')
                        .datum(feature)
                        .attr('d', d3Path)
                        .attr('stroke', 'blue') // Styling the boundary
                        .attr('stroke-width', 1)
                        .attr('fill', 'none');
                });

                // Append the SVG container to the map's DOM element
                map.getTargetElement().appendChild(this.svgContainer.node());
                return this.svgContainer.node();
            }
        }

        // Load the GeoJSON data
        d3.json('https://ayiemba.github.io/sample-data/ZWE_adm2_A.geojson').then(function (geojson) {
            const options = { tolerance: 0.01, highQuality: false };
            const simplifiedGeo = turf.simplify(geojson, options);

            console.log('simplified geojson:', simplifiedGeo);

            // // Using Turf to ensure the correct winding order
            // const fixedGeoJSON = turf.featureCollection(
            //     geojson.features.map((feature) => {
            //         if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
            //             // Flip the polygons if they are incorrectly ordered
            //             feature.geometry.coordinates = feature.geometry.coordinates.map((coords) =>
            //                 turf.flip(turf.polygon(coords)).geometry.coordinates
            //             );
            //         }
            //         return feature;
            //     })
            // );

            // Create and add the custom layer
            const layer = new CanvasLayer({
                features: simplifiedGeo,
            });
            map.addLayer(layer);

            // Render the map
            map.render();
        });
    </script>
</body>

</html>